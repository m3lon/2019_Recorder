## 0x01 Python 魔法方法、特性和迭代器
- 关于python2中旧式类转换为新式类，通过设置`__metaclass__=type`(元类)或者直接/间接的继承Object，python3中没有旧式类，所有的类都隐式的继承Object
#### 魔术方法
- 最常用的魔术方法构造函数：`__init__`和不常用的魔术方法析构函数：`__del__`
- 重写普通方法和构造函数：普通方法直接覆盖就好了，关于构造方法，如果子类重新构造方法，超类构造方法中的属性就不能访问了，这时需要通过下面两种方法解决
    - 调用未关联的超类构造方法：`SuperClass.__init__()`
    - 新式类使用super方法：`super().__init__()`
- 科普一下关联方法与未关联方法：当实例调用方法时，方法的参数self将自动关联实例，称为关联的方法；如果通过类调用方法，就没有实例与之相关联，这时就可以任意指定self了，这种方法就称为未关联方法
- 元素访问，序列和映射协议的实现相关的魔术方法：`__len__(self) __getitem__(self, key) __setitem__(self, key, value) __delitem__(self, key)` 以及通过这些方法的复写也可实现对list、dict和str的派生

#### 特性
- 函数property(获取方法如get_size, 设置方法set_size)，参数可不指定，也可指定一个（只读）
- 静态方法和类方法创建方法：将它们分别包装在staticmethod和classmethod类的对象中`smeth = staticmethod(smeth)` 为避免繁琐的代码，可使用装饰器`@staticmethod`
- 对象属性的访问：
    - `__getattribute__(self, name)` 在属性被访问时自动调用，只适用于新式类
    - `__getattr__` 在属性被访问而对象没有这样的属性时自动被调用
    - `__setattr__` 试图给属性赋值时自动调用
    - `__delattr__`试图删除属性时自动调用

#### 迭代器
- `__iter__`返回一个迭代器，它是包含方法`__next__`的对象，调用此方法时可不提供任何参数
- 实现了方法`__iter__`的对象是可迭代的，而实现了方法`__next__`的对象是迭代器
- 可使用构造函数list显式的将迭代器转换为列表

#### 生成器
- 包含yield语句的函数都被称为生成器
- 简单生成器：生成器推导（生成器表达式）工作原理与列表推导相同，但不是创建一个列表，而是返回一个生成器
- 迭代的优势：不立即执行，相比列表推导，如果要包装可迭代对象（可能生成大量的值），使用列表推导将立即实例化一个列表，占用内存空间
- 递归式生成器：如处理任意层嵌套的列表
