时间过的张牙舞爪，又是新的一周啦！先说这一周的学习任务：  
1. subDomainsBrute源码分析
2. Python3版的子域名挖掘

娱乐：  
1. 复仇者联盟1-4
2. 准备上班的衣服

好啦，开始吧！  

### 0x01 subDomainsBrute源码分析

#### 模块分析
1. 命令行解析模块 
2. 多进程+协程模块
3. dns解析模块
4. 辅助（无法称之为模块吧）：域名解析地址加载、爆破域名加载
5. 关键数据结构把握

### 扩展
1. 命令行参数中的"-"与"--"的区别
- Unix风格： 一个减号 参数就是一个字母
- GNU风格：两个减号 参数是一个单词或短语 
- 至于将上面两种混合的，可以理解为--后面的单词是单减号-字母的全称

2. argparse模块  
- https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p03_parsing_command_line_options.html
- http://blog.xiayf.cn/2013/03/30/argparse/

3. Multiprocessing模块  
https://timber.io/blog/multiprocessing-vs-multithreading-in-python-what-you-need-to-know/  
- IO密集型：多线程
- 计算密集型：多进程  
下面是一些自己的理解：  
- 多线程并不是并行CPU在跑程序，而是一个CPU，举个栗子，上次AWVS生成报告的时候，每个扫描目标扫描时间不同，但我不能一个一个线性等待，我想实现的效果是哪个扫描完了就先把报告保存下来，于是就想到了多线程threading， 这就属于network中的空闲时间太多如何充分利用呢，就是多线程。再比如，下载过程中CPU可以并行的从不同网站数据源下载最后再组合。总结一下，多线程主要适用于可能会存在大量等待时间的场景如network、IO操作
- 关于多线程的锁：当多线程操作共有数据资源时，如果不加锁会产生混乱
- 多进程Multiprocessing是并行CPU，每个进程都有自己的GIL，所以并不存在不加锁数据混乱的情况，参见博文注意多进程的缺陷：整个内存被复制到各个子进程中，内存数据量较大时会产生很大的开销
- 使用方法
    ```python
    p = multiprocessing.Process(target=run_process,args=(args[0], ))
    all_process.append(p)
    p.start()
    ```

4. 进程、线程、协程
    想以后看看计算机操作系统...  
    python中由于存在GIL（全局解释锁），会阻止一个程序同时执行两个线程，所以Cpython下的多线程并不是并发多线程，而是系统在不同的时间片之间切换实现的并行多线程
    - 进程：程序的实例，在内存中，一般通过多线程实现，比如一个线程用于等待键盘输入，一个线程用于显示数据，所以可以理解一个进程需要执行多个子任务，就由线程去完成
    - 线程：上面解释的差不多了，不过这里跟协程比较一下，线程依然是系统调度的，而协程则是由代码调度的（由程序员）
    - 协程：见8 协程为微线程，把线程中的一个个函数叫做子程序，子程序在执行过程中可以中断去执行其他子程序，这就是协程
    数量级： 进程 > 线程 > 协程 Mac下可以直接搜索活动监视器看到进程和线程情况

5. dnspython
    好像没什么可写的，在网上找个教程，会用就好了

6. python中的下划线
- _xxx 不能用于from module import *  以单下划线开头表示的是protected的变量，即只能允许本身与子类进行访问
- __xxx 表示私有类型的变量，只能允许本类访问
- `__xxx__` 系统定义名字 如`__init__（）`表示类的构造函数

7. signal模块  
用于处理信号：https://juejin.im/post/5c0a4a92f265da61682b2f65  
常用方法：(如处理Ctrl+C为退出程序)  
    ```py
    import signal
    signal.signal(signal.SIGINT, handle_int)
    def handle_int(sig, frame):
        exit(-1)
    ```

8. gevent和协程  
参考：https://cloud.tencent.com/developer/article/1328517  
- 线程与协程：协程就是微线程，线程是系统级别的，由系统调用；协程是程序级别的，由程序调用；我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是协程。协程实现依赖于协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。

- 协程的优点：高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。所以才是大佬在扫描器中应用协程的原因吧

- 协程的缺点：无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。然鹅，这个扫描器就是将协程与进程配合在一起提高扫描效率的，所以子域名扫描是属于CPU密集型应用吗

- 估计是一篇比较旧的博客：python如何实现协程：
    1. yield: 从中断子程序去执行另一个子程序的角度讲，如刚才看的栗子，一个线程实现“同时”(在任何时刻，只有一个协程在运行)执行两个子程序 搭配send启用生成器
    2. greenlet: 手动切换
    3. gevent: 当我们在受限于网络或IO的函数中使用gevent，这些函数会被协作式的调度，gevent的真正能力会得到发挥。Gevent处理了所有的细节，来保证你的网络库会在可能的时候，隐式交出greenlet上下文的执行权(两个子任务之间的切换也就是上下文切换。)。参考：http://hhkbp2.github.io/gevent-tutorial/#_1
    4. 见13 python3.5协程

9. python yeild
- 可迭代对象
    for...in...所有可以以该语法读取的对象（所有实现了`__next__`方法的对象--本质上for循环就是不断地调用迭代器的next方法）都是可迭代的，如列表、字符串、文件。这些都是先将内容存储到内存中，然后读取出来，不过当数据量很大时，这样就不明智了
- 生成器
    ```python
    my_generator = (x*x for x in range(10))
    for i in my_generator:
        print(i)
    ```
    看上去与列表生成式很像，只是将[]变为()，但是这样生成的对象为生成器
- yield
    返回生成器的关键字

10. select模块  
参考：https://www.cnblogs.com/MnCu8261/p/6403340.html 现在先不想看

11. 队列和列表
    队列是一种数据结构；咦？列表也是数据结构呀

12. python的运行顺序  
    Python中首先执行最先出现的非函数定义和非类定义的没有缩进的代码，会从前到后执行  
    程序中为了区分主动执行还是被调用，Python引入了变量      `__name__`，当文件是被调用时，`__name__`的值为模块名，当文件被执行时，__name__为`__main__`。因此，若是文件主动执行了，则最好写成跟上面的例子一样，main之前不要有可执行代码，这样做到程序从main（）开始，流程逻辑性强；若是文件作为模块被调用，则可以不用写main（），从上而下顺序执行

13. python3 协程：async/await 

14. 异步IO
    https://zhuanlan.zhihu.com/p/37640811

写在最后：真不想承认一周能完成的任务，我拖了半个月，今天上班了，以后就不能那么随心所欲了，即使自己学不下去的时候也要强迫自己能静下心来！